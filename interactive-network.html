<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Network Animator</title>
  <style>
    :root {
      color-scheme: light;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f8f1de;
      color: #2f2c28;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      padding: 1rem 1.5rem 0.5rem;
    }
    header h1 {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 600;
    }
    header p {
      margin: 0.25rem 0 0;
      max-width: 600px;
      font-size: 0.95rem;
      line-height: 1.4;
    }
    #app {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 1fr) 320px;
      gap: 1.5rem;
      padding: 0 1.5rem 1.5rem;
    }
    canvas {
      width: 100%;
      height: 100%;
      border-radius: 16px;
      background: transparent;
      box-shadow: 0 10px 40px rgba(39, 33, 25, 0.18);
    }
    .controls {
      padding: 1.25rem;
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.75);
      backdrop-filter: blur(8px);
      box-shadow: 0 10px 40px rgba(39, 33, 25, 0.14);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .controls h2 {
      margin: 0;
      font-size: 1.15rem;
      font-weight: 600;
    }
    .control {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.9rem;
    }
    .control label {
      font-weight: 600;
    }
    .control input[type="range"],
    .control input[type="color"],
    .control select {
      width: 100%;
    }
    .control input[type="range"] {
      accent-color: #ba6d39;
    }
    .control .value {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.8rem;
      color: rgba(47, 44, 40, 0.75);
    }
    .toggles {
      display: flex;
      gap: 0.75rem;
      align-items: center;
    }
    .toggles label {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      font-weight: 500;
      font-size: 0.85rem;
    }
    footer {
      padding: 0.75rem 1.5rem 1.5rem;
      font-size: 0.8rem;
      color: rgba(47, 44, 40, 0.6);
    }
    @media (max-width: 960px) {
      #app {
        grid-template-columns: 1fr;
      }
      .controls {
        order: -1;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Interactive Network Animator</h1>
    <p>
      A high-performance canvas sketch that mirrors the Metcalfe generator aesthetic. Use the controls to tweak node layout,
      palette, and build speed. The rendering core is architecture-ready for WebGL or OffscreenCanvas upgrades.
    </p>
  </header>
  <div id="app">
    <canvas id="networkCanvas"></canvas>
    <aside class="controls">
      <h2>Appearance</h2>
      <div class="control">
        <label for="nodeCount">Node Count</label>
        <input id="nodeCount" type="range" min="3" max="96" value="36">
        <div class="value"><span>3</span><span id="nodeCountValue">36</span><span>96</span></div>
      </div>
      <div class="control">
        <label for="nodeRadius">Node Radius</label>
        <input id="nodeRadius" type="range" min="4" max="18" value="11">
        <div class="value"><span>4</span><span id="nodeRadiusValue">11</span><span>18</span></div>
      </div>
      <div class="control">
        <label for="radius">Graph Radius</label>
        <input id="radius" type="range" min="120" max="320" value="220">
        <div class="value"><span>120</span><span id="radiusValue">220</span><span>320</span></div>
      </div>
      <div class="control">
        <label for="lineWidth">Line Width</label>
        <input id="lineWidth" type="range" min="0.25" max="3" step="0.05" value="0.9">
        <div class="value"><span>0.25</span><span id="lineWidthValue">0.90</span><span>3.00</span></div>
      </div>
      <div class="control">
        <label for="lineColor">Line Color</label>
        <input id="lineColor" type="color" value="#6b5f4b">
      </div>
      <div class="control">
        <label for="backgroundColor">Background</label>
        <input id="backgroundColor" type="color" value="#f0e1c6">
      </div>
      <div class="control">
        <label for="pattern">Pattern</label>
        <select id="pattern">
          <option value="circular" selected>Circular sweep</option>
          <option value="opposite">Opposite pairs</option>
          <option value="alternating">Alternating fill</option>
        </select>
      </div>
      <div class="control">
        <label for="buildRate">Build Rate (nodes/sec)</label>
        <input id="buildRate" type="range" min="0.5" max="20" step="0.5" value="6">
        <div class="value"><span>0.5</span><span id="buildRateValue">6.0</span><span>20</span></div>
      </div>
      <div class="toggles">
        <label><input id="animate" type="checkbox" checked> Animate build</label>
        <label><input id="drawConnections" type="checkbox" checked> Show connections</label>
      </div>
    </aside>
  </div>
  <footer>
    Canvas animation prototype for metcalfe-generator &mdash; upgrade paths: OffscreenCanvas, WebGL instancing, and reactive control bindings.
  </footer>

  <script>
    (() => {
      const MIN_NODES = 3;
      const canvas = document.getElementById('networkCanvas');
      const ctx = canvas.getContext('2d', { alpha: true });
      if (!ctx) {
        throw new Error('Canvas 2D context unavailable.');
      }

      const dpi = window.devicePixelRatio || 1;
      const nodePalette = [
        '#3a725e', '#375d8f', '#89c4f4', '#b84c38', '#e6964e',
        '#8b5e3c', '#f1a99b', '#0c5b8f', '#1d8a6d', '#ffb347'
      ];

      const state = {
        nodeCount: 36,
        nodeRadius: 11,
        radius: 220,
        lineWidth: 0.9,
        lineColor: '#6b5f4b',
        backgroundColor: '#f0e1c6',
        pattern: 'circular',
        buildRate: 6, // nodes per second
        animate: true,
        drawConnections: true
      };

      let lastTimestamp = performance.now();
      let visibleNodeProgress = state.animate ? MIN_NODES : state.nodeCount;

      const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
      const lerp = (a, b, t) => a + (b - a) * t;

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.floor(rect.width * dpi);
        canvas.height = Math.floor(rect.height * dpi);
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpi, dpi);
        visibleNodeProgress = clamp(visibleNodeProgress, MIN_NODES, state.nodeCount);
      }

      function calculatePositions(count, pattern) {
        const positions = new Float32Array(count * 2);
        const cx = canvas.clientWidth / 2;
        const cy = canvas.clientHeight / 2;
        const r = Math.min(state.radius, Math.min(cx, cy) - state.nodeRadius - 12);
        const angleStep = (Math.PI * 2) / count;

        const indices = new Uint16Array(count);
        if (pattern === 'opposite') {
          let left = 0;
          let right = Math.floor(count / 2);
          for (let i = 0; i < count; i++) {
            indices[i] = (i % 2 === 0) ? (left++) % count : (right++) % count;
          }
        } else if (pattern === 'alternating') {
          let idx = 0;
          for (let i = 0; i < count; i += 2) indices[idx++] = i;
          for (let i = 1; i < count; i += 2) indices[idx++] = i;
        } else {
          for (let i = 0; i < count; i++) {
            indices[i] = i;
          }
        }

        const baseAngle = -Math.PI; // anchor initial node at 12 o'clock
        for (let i = 0; i < count; i++) {
          const angle = baseAngle + indices[i] * angleStep;
          const x = cx + r * Math.sin(angle);
          const y = cy + r * Math.cos(angle);
          positions[i * 2] = x;
          positions[i * 2 + 1] = y;
        }

        return positions;
      }

      function drawFrame(delta) {
        const { width, height } = canvas;
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = state.backgroundColor;
        ctx.fillRect(0, 0, width, height);

        const targetVisible = Math.max(MIN_NODES, Math.floor(state.nodeCount));

        if (state.animate) {
          visibleNodeProgress = Math.min(
            targetVisible,
            visibleNodeProgress + (delta * state.buildRate * 0.001)
          );
        } else {
          visibleNodeProgress = targetVisible;
        }

        const baseCount = Math.min(targetVisible, Math.max(MIN_NODES, Math.floor(visibleNodeProgress)));
        const transitioning = state.animate && baseCount < targetVisible;
        const nextCount = transitioning ? baseCount + 1 : baseCount;
        const transition = transitioning ? clamp(visibleNodeProgress - baseCount, 0, 1) : 0;

        const currentPositions = calculatePositions(baseCount, state.pattern);
        const nextPositions = calculatePositions(nextCount, state.pattern);

        const nodes = [];
        for (let i = 0; i < baseCount; i++) {
          const x = transitioning
            ? lerp(currentPositions[i * 2], nextPositions[i * 2], transition)
            : currentPositions[i * 2];
          const y = transitioning
            ? lerp(currentPositions[i * 2 + 1], nextPositions[i * 2 + 1], transition)
            : currentPositions[i * 2 + 1];
          nodes.push({ x, y, scale: 1, index: i });
        }

        if (transitioning && nextCount > baseCount) {
          const idx = baseCount;
          nodes.push({
            x: nextPositions[idx * 2],
            y: nextPositions[idx * 2 + 1],
            scale: transition,
            index: idx
          });
        }

        const visibleCount = Math.min(
          targetVisible,
          Math.max(MIN_NODES, Math.floor(baseCount + (nextCount - baseCount) * transition))
        );

        ctx.lineWidth = state.lineWidth;
        ctx.strokeStyle = state.lineColor;
        if (state.drawConnections) {
          ctx.beginPath();
          for (let i = 0; i < visibleCount; i++) {
            const nodeA = nodes[i];
            if (!nodeA) continue;
            for (let j = i + 1; j < visibleCount; j++) {
              const nodeB = nodes[j];
              if (!nodeB) continue;
              ctx.moveTo(nodeA.x, nodeA.y);
              ctx.lineTo(nodeB.x, nodeB.y);
            }
          }
          ctx.stroke();
        }

        ctx.globalAlpha = 0.95;
        nodes.forEach(node => {
          const scale = node.scale;
          if (scale <= 0) return;
          ctx.save();
          ctx.globalAlpha = scale < 1 ? scale : 1;
          ctx.fillStyle = nodePalette[node.index % nodePalette.length];
          ctx.beginPath();
          const radius = state.nodeRadius * (scale < 1 ? scale : 1);
          ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
        ctx.globalAlpha = 1;
      }

      function loop(timestamp) {
        const delta = clamp(timestamp - lastTimestamp, 0, 32);
        lastTimestamp = timestamp;
        drawFrame(delta);
        requestAnimationFrame(loop);
      }

      const controls = [
        ['nodeCount', v => {
          state.nodeCount = parseInt(v, 10);
          document.getElementById('nodeCountValue').textContent = v;
          visibleNodeProgress = state.animate ? MIN_NODES : state.nodeCount;
        }],
        ['nodeRadius', v => { state.nodeRadius = parseFloat(v); document.getElementById('nodeRadiusValue').textContent = v; }],
        ['radius', v => {
          state.radius = parseFloat(v);
          document.getElementById('radiusValue').textContent = v;
        }],
        ['lineWidth', v => { state.lineWidth = parseFloat(v); document.getElementById('lineWidthValue').textContent = parseFloat(v).toFixed(2); }],
        ['lineColor', v => { state.lineColor = v; }],
        ['backgroundColor', v => { state.backgroundColor = v; }],
        ['pattern', v => {
          state.pattern = v;
          visibleNodeProgress = state.animate ? MIN_NODES : state.nodeCount;
        }],
        ['buildRate', v => {
          state.buildRate = parseFloat(v);
          document.getElementById('buildRateValue').textContent = parseFloat(v).toFixed(1);
        }],
        ['animate', v => {
          state.animate = v;
          visibleNodeProgress = v ? MIN_NODES : state.nodeCount;
          lastTimestamp = performance.now();
        }],
        ['drawConnections', v => { state.drawConnections = v; }]
      ];

      controls.forEach(([id, handler]) => {
        const el = document.getElementById(id);
        if (el.type === 'checkbox') {
          el.addEventListener('change', () => handler(el.checked));
        } else {
          el.addEventListener('input', () => handler(el.value));
        }
      });

      window.addEventListener('resize', () => {
        resizeCanvas();
      });

      resizeCanvas();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
