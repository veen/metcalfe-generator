<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Network Animator</title>
  <style>
    :root {
      color-scheme: light;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #ffffff;
      color: #111111;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      padding: 1rem 1.5rem 0.75rem;
    }
    header h1 {
      margin: 0;
      font-size: 1.45rem;
      font-weight: 600;
      letter-spacing: -0.01em;
    }
    header p {
      margin: 0.25rem 0 0;
      max-width: 600px;
      font-size: 0.95rem;
      line-height: 1.5;
      color: #5f6368;
    }
    #app {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 1fr) 320px;
      gap: 1.5rem;
      padding: 0 1.5rem 1.5rem;
    }
    canvas {
      width: 100%;
      height: auto;
      aspect-ratio: 1 / 1;
      display: block;
      align-self: start;
      border-radius: 16px;
      background: #ffffff;
      border: 1px solid #e6e6e6;
      box-shadow:
        0 20px 50px rgba(15, 15, 15, 0.08),
        0 1px 2px rgba(15, 15, 15, 0.08);
    }
    .control-pane {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      align-items: flex-start;
    }
    .controls-card {
      padding: 1.75rem 1.5rem 1.5rem;
      border-radius: 16px;
      background: #ffffff;
      border: 1px solid #e8e8e8;
      box-shadow:
        0 18px 42px rgba(15, 15, 15, 0.06),
        0 1px 3px rgba(15, 15, 15, 0.08);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      width: 100%;
    }
    .tabs {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.22rem 0.28rem;
      background: #f1f1f1;
      border-radius: 14px;
      border: 1px solid #e1e1e1;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.65);
      margin-left: 0;
      margin-bottom: -0.35rem;
      position: relative;
      z-index: 1;
    }
    .tab {
      border: 1px solid transparent;
      background: transparent;
      color: #3b3b3d;
      border-radius: 8px;
      padding: 0.4rem 1.2rem;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }
    .tab:hover {
      background: rgba(255, 255, 255, 0.7);
    }
    .tab-active {
      background: #ffffff;
      color: #111111;
      box-shadow:
        0 1px 3px rgba(15, 15, 15, 0.1),
        inset 0 0 0 1px #d4d4d4;
      border-color: #d9d9d9;
    }
    .panel {
      display: none;
      flex-direction: column;
      gap: 1rem;
    }
    .panel-active {
      display: flex;
    }
    .color-grid {
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }
    .color-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      padding: 0.55rem 0.75rem;
      background: #f0f0f0;
      border-radius: 12px;
      border: 1px solid #e3e3e3;
    }
    .color-item input[type="color"] {
      width: 48px;
      height: 32px;
      border: none;
      background: transparent;
      cursor: pointer;
    }
    .color-item button {
      border: 1px solid #d0d0d0;
      background: #ffffff;
      color: #343434;
      padding: 0.3rem 0.75rem;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }
    .color-item button:hover {
      background: #f4f4f4;
    }
    .control {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.9rem;
    }
    .control label {
      font-weight: 600;
      color: #1f1f20;
    }
    .control input[type="range"],
    .control input[type="color"],
    .control select {
      width: 100%;
    }
    .control input[type="range"] {
      accent-color: #111111;
      height: 6px;
      -webkit-appearance: none;
      background: transparent;
    }
    .control input[type="range"]::-webkit-slider-runnable-track {
      height: 6px;
      border-radius: 999px;
      background: linear-gradient(to right, #111111 var(--progress, 50%), #e5e5e5 var(--progress, 50%));
    }
    .control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 1px solid #111111;
      background: #ffffff;
      margin-top: -5px;
      transition: transform 0.15s ease;
    }
    .control input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.05);
    }
    .control input[type="range"]::-moz-range-track {
      height: 6px;
      border-radius: 999px;
      background: #e5e5e5;
    }
    .control input[type="range"]::-moz-range-progress {
      background: #111111;
      border-radius: 999px;
    }
    .control input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border: 1px solid #111111;
      border-radius: 50%;
      background: #ffffff;
      transition: transform 0.15s ease;
    }
    .control input[type="range"]::-moz-range-thumb:hover {
      transform: scale(1.05);
    }
    .control .value {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.8rem;
      color: #7a7d81;
    }
    .toggles {
      display: flex;
      gap: 0.75rem;
      align-items: center;
    }
    .toggles label {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      font-weight: 500;
      font-size: 0.85rem;
    }
    .button {
      appearance: none;
      border-radius: 999px;
      padding: 0.55rem 1.5rem;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      border: 1px solid #d6d6d6;
      background: #ffffff;
      color: #1e1e1e;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease;
    }
    .button:hover {
      background: #f5f5f5;
    }
    .button:focus-visible {
      outline: 2px solid rgba(17, 17, 17, 0.2);
      outline-offset: 2px;
    }
    .button-primary {
      background: #111111;
      color: #fdfdfd;
      border-color: #111111;
      box-shadow: 0 10px 26px rgba(17, 17, 17, 0.25);
    }
    .button-primary:hover {
      background: #000000;
    }
    .button-primary:active {
      transform: translateY(0);
      box-shadow: 0 6px 16px rgba(17, 17, 17, 0.24);
    }
    footer {
      padding: 0.75rem 1.5rem 1.5rem;
      font-size: 0.8rem;
      color: #8a8d92;
    }
    @media (max-width: 960px) {
      #app {
        grid-template-columns: 1fr;
      }
      .control-pane {
        order: -1;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Interactive Network Animator</h1>
    <p>
      A high-performance canvas sketch that mirrors the Metcalfe generator aesthetic. Use the controls to tweak node layout,
      palette, and build speed. The rendering core is architecture-ready for WebGL or OffscreenCanvas upgrades.
    </p>
  </header>
  <div id="app">
    <canvas id="networkCanvas"></canvas>
    <aside class="control-pane">
      <div class="tabs" role="tablist">
        <button class="tab tab-active" id="tab-structure" data-target="panel-structure" role="tab" aria-selected="true">Structure</button>
        <button class="tab" id="tab-colors" data-target="panel-colors" role="tab" aria-selected="false">Colors</button>
      </div>
      <div class="controls-card">
        <div class="panel panel-active" id="panel-structure" role="tabpanel" aria-labelledby="tab-structure">
          <div class="control">
            <label for="nodeCount">Node Count</label>
            <input id="nodeCount" type="range" min="3" max="96" value="36">
            <div class="value"><span>3</span><span id="nodeCountValue">36</span><span>96</span></div>
          </div>
          <div class="control">
            <label for="nodeRadius">Node Radius</label>
            <input id="nodeRadius" type="range" min="4" max="18" value="11">
            <div class="value"><span>4</span><span id="nodeRadiusValue">11</span><span>18</span></div>
          </div>
          <div class="control">
            <label for="radius">Graph Radius</label>
            <input id="radius" type="range" min="120" max="320" value="320">
            <div class="value"><span>120</span><span id="radiusValue">320</span><span>320</span></div>
          </div>
          <div class="control">
            <label for="lineWidth">Line Width</label>
            <input id="lineWidth" type="range" min="0.25" max="3" step="0.05" value="0.5">
            <div class="value"><span>0.25</span><span id="lineWidthValue">0.50</span><span>3.00</span></div>
          </div>
          <div class="control">
            <label for="pattern">Pattern</label>
            <select id="pattern">
              <option value="circular-alternating" selected>Circular alternating</option>
              <option value="circular">Circular sweep</option>
              <option value="opposite">Opposite pairs</option>
              <option value="alternating">Alternating fill</option>
            </select>
          </div>
          <div class="control">
            <label for="buildRate">Build Rate (nodes/sec)</label>
            <input id="buildRate" type="range" min="0.5" max="20" step="0.5" value="6">
            <div class="value"><span>0.5</span><span id="buildRateValue">6.0</span><span>20</span></div>
          </div>
          <div class="toggles">
            <button id="playToggle" type="button" class="button button-primary">Pause</button>
          </div>
        </div>
        <div class="panel" id="panel-colors" role="tabpanel" aria-labelledby="tab-colors">
          <div class="control">
            <label for="lineColor">Line Color</label>
            <input id="lineColor" type="color" value="#646464">
          </div>
          <div class="control">
            <label for="backgroundColor">Background</label>
            <input id="backgroundColor" type="color" value="#ffffff">
          </div>
          <div class="control">
            <label>Node Colors</label>
            <div id="nodeColorList" class="color-grid"></div>
          </div>
          <div class="control">
            <label for="newNodeColor">Add Node Color</label>
            <div style="display:flex; gap:0.75rem; align-items:center;">
              <input id="newNodeColor" type="color" value="#ffffff" title="New node color">
              <button id="addNodeColor" type="button" class="button">Add Color</button>
            </div>
          </div>
        </div>
      </div>
    </aside>
  </div>
  <footer>
    Canvas animation prototype for metcalfe-generator &mdash; upgrade paths: OffscreenCanvas, WebGL instancing, and reactive control bindings.
  </footer>

  <script>
    (() => {
      const MIN_NODES = 3;
      const canvas = document.getElementById('networkCanvas');
      const ctx = canvas.getContext('2d', { alpha: true });
      if (!ctx) {
        throw new Error('Canvas 2D context unavailable.');
      }

      const dpi = window.devicePixelRatio || 1;
      const allNodeColors = [
        '#3a725e', '#375d8f', '#89c4f4', '#b84c38', '#e6964e',
        '#8b5e3c', '#f1a99b', '#0c5b8f', '#1d8a6d', '#ffb347'
      ];
      const defaultNodeColors = allNodeColors.slice(0, 4);

      const state = {
        nodeCount: 36,
        nodeRadius: 11,
        radius: 320,
        lineWidth: 0.5,
        lineColor: '#646464',
        backgroundColor: '#ffffff',
        pattern: 'circular-alternating',
        buildRate: 6, // nodes per second
        animate: true,
        nodeColors: [...defaultNodeColors]
      };

      let lastTimestamp = performance.now();
      let visibleNodeProgress = state.animate ? MIN_NODES : state.nodeCount;

      const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
      const lerp = (a, b, t) => a + (b - a) * t;

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.floor(rect.width * dpi);
        canvas.height = Math.floor(rect.height * dpi);
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpi, dpi);
        visibleNodeProgress = clamp(visibleNodeProgress, MIN_NODES, state.nodeCount);
      }

      function calculatePositions(count, pattern) {
        const positions = new Float32Array(count * 2);
        const cx = canvas.clientWidth / 2;
        const cy = canvas.clientHeight / 2;
        const r = Math.min(state.radius, Math.min(cx, cy) - state.nodeRadius - 12);
        const angleStep = (Math.PI * 2) / count;

        const indices = new Uint16Array(count);
        if (pattern === 'opposite') {
          let left = 0;
          let right = Math.floor(count / 2);
          for (let i = 0; i < count; i++) {
            indices[i] = (i % 2 === 0) ? (left++) % count : (right++) % count;
          }
        } else if (pattern === 'circular-alternating') {
          indices[0] = 0;
          let left = 1;
          let right = count - 1;
          let takeRight = true;
          for (let i = 1; i < count; i++) {
            if (takeRight && right >= left) {
              indices[i] = right--;
            } else if (!takeRight && left <= right + 1) {
              indices[i] = left++;
            } else if (right >= left) {
              indices[i] = right--;
            } else {
              indices[i] = left++;
            }
            takeRight = !takeRight;
          }
        } else if (pattern === 'alternating') {
          let idx = 0;
          for (let i = 0; i < count; i += 2) indices[idx++] = i;
          for (let i = 1; i < count; i += 2) indices[idx++] = i;
        } else {
          for (let i = 0; i < count; i++) {
            indices[i] = i;
          }
        }

        const baseAngle = -Math.PI; // anchor initial node at 12 o'clock
        for (let i = 0; i < count; i++) {
          const angle = baseAngle + indices[i] * angleStep;
          const x = cx + r * Math.sin(angle);
          const y = cy + r * Math.cos(angle);
          positions[i * 2] = x;
          positions[i * 2 + 1] = y;
        }

        return positions;
      }

      function drawFrame(delta) {
        const { width, height } = canvas;
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = state.backgroundColor;
        ctx.fillRect(0, 0, width, height);

        const targetVisible = Math.max(MIN_NODES, Math.floor(state.nodeCount));

        if (state.animate) {
          visibleNodeProgress = Math.min(
            targetVisible,
            visibleNodeProgress + (delta * state.buildRate * 0.001)
          );
        } else {
          visibleNodeProgress = targetVisible;
        }

        const baseCount = Math.min(targetVisible, Math.max(MIN_NODES, Math.floor(visibleNodeProgress)));
        const transitioning = state.animate && baseCount < targetVisible;
        const nextCount = transitioning ? baseCount + 1 : baseCount;
        const transition = transitioning ? clamp(visibleNodeProgress - baseCount, 0, 1) : 0;

        const currentPositions = calculatePositions(baseCount, state.pattern);
        const nextPositions = calculatePositions(nextCount, state.pattern);

        const nodes = [];
        for (let i = 0; i < baseCount; i++) {
          const x = transitioning
            ? lerp(currentPositions[i * 2], nextPositions[i * 2], transition)
            : currentPositions[i * 2];
          const y = transitioning
            ? lerp(currentPositions[i * 2 + 1], nextPositions[i * 2 + 1], transition)
            : currentPositions[i * 2 + 1];
          nodes.push({ x, y, scale: 1, index: i });
        }

        if (transitioning && nextCount > baseCount) {
          const idx = baseCount;
          nodes.push({
            x: nextPositions[idx * 2],
            y: nextPositions[idx * 2 + 1],
            scale: transition,
            index: idx
          });
        }

        const visibleCount = Math.min(
          targetVisible,
          Math.max(MIN_NODES, Math.floor(baseCount + (nextCount - baseCount) * transition))
        );

        const palette = state.nodeColors.length ? state.nodeColors : defaultNodeColors;
        ctx.lineWidth = state.lineWidth;
        ctx.strokeStyle = state.lineColor;
        ctx.beginPath();
        for (let i = 0; i < visibleCount; i++) {
          const nodeA = nodes[i];
          if (!nodeA) continue;
          for (let j = i + 1; j < visibleCount; j++) {
            const nodeB = nodes[j];
            if (!nodeB) continue;
            ctx.moveTo(nodeA.x, nodeA.y);
            ctx.lineTo(nodeB.x, nodeB.y);
          }
        }
        ctx.stroke();

        ctx.globalAlpha = 0.95;
        nodes.forEach(node => {
          const scale = node.scale;
          if (scale <= 0) return;
          ctx.save();
          ctx.globalAlpha = scale < 1 ? scale : 1;
          ctx.fillStyle = palette[node.index % palette.length];
          ctx.beginPath();
          const radius = state.nodeRadius * (scale < 1 ? scale : 1);
          ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
        ctx.globalAlpha = 1;
      }

      function loop(timestamp) {
        const delta = clamp(timestamp - lastTimestamp, 0, 32);
        lastTimestamp = timestamp;
        drawFrame(delta);
        requestAnimationFrame(loop);
      }

      const rangeInputs = Array.from(document.querySelectorAll('input[type="range"]'));

      function updateRangeProgress(el) {
        if (!el || el.type !== 'range') return;
        const min = parseFloat(el.min) || 0;
        const max = parseFloat(el.max) || 100;
        const value = parseFloat(el.value);
        const ratio = max === min ? 0 : (value - min) / (max - min);
        el.style.setProperty('--progress', `${Math.max(0, Math.min(1, ratio)) * 100}%`);
      }

      rangeInputs.forEach(updateRangeProgress);

      const controls = [
        ['nodeCount', v => {
          state.nodeCount = parseInt(v, 10);
          document.getElementById('nodeCountValue').textContent = v;
          visibleNodeProgress = state.animate ? MIN_NODES : state.nodeCount;
        }],
        ['nodeRadius', v => { state.nodeRadius = parseFloat(v); document.getElementById('nodeRadiusValue').textContent = v; }],
        ['radius', v => {
          state.radius = parseFloat(v);
          document.getElementById('radiusValue').textContent = v;
        }],
        ['lineWidth', v => { state.lineWidth = parseFloat(v); document.getElementById('lineWidthValue').textContent = parseFloat(v).toFixed(2); }],
        ['lineColor', v => { state.lineColor = v; }],
        ['backgroundColor', v => { state.backgroundColor = v; }],
        ['pattern', v => {
          state.pattern = v;
          visibleNodeProgress = state.animate ? MIN_NODES : state.nodeCount;
        }],
        ['buildRate', v => {
          state.buildRate = parseFloat(v);
          document.getElementById('buildRateValue').textContent = parseFloat(v).toFixed(1);
        }]
      ];

      controls.forEach(([id, handler]) => {
        const el = document.getElementById(id);
        if (!el) return;
        el.addEventListener('input', () => {
          if (el.type === 'range') {
            updateRangeProgress(el);
          }
          handler(el.value);
        });
      });

      const tabs = Array.from(document.querySelectorAll('.tab'));
      const panels = new Map(
        Array.from(document.querySelectorAll('.panel')).map(panel => [panel.id, panel])
      );

      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          if (tab.classList.contains('tab-active')) return;
          tabs.forEach(btn => {
            btn.classList.toggle('tab-active', btn === tab);
            btn.setAttribute('aria-selected', btn === tab ? 'true' : 'false');
          });
          panels.forEach(panel => panel.classList.remove('panel-active'));
          const targetPanel = panels.get(tab.dataset.target);
          if (targetPanel) {
            targetPanel.classList.add('panel-active');
          }
        });
      });

      const nodeColorList = document.getElementById('nodeColorList');
      const newNodeColorInput = document.getElementById('newNodeColor');
      const addNodeColorButton = document.getElementById('addNodeColor');

      function renderNodeColorList() {
        nodeColorList.innerHTML = '';
        const palette = state.nodeColors.length ? state.nodeColors : defaultNodeColors;
        palette.forEach((color, index) => {
          const item = document.createElement('div');
          item.className = 'color-item';
          const input = document.createElement('input');
          input.type = 'color';
          input.value = color;
          input.setAttribute('aria-label', `Node color ${index + 1}`);
          input.addEventListener('input', event => {
            state.nodeColors[index] = event.target.value;
          });
          item.appendChild(input);

          if (state.nodeColors.length > 1) {
            const removeButton = document.createElement('button');
            removeButton.type = 'button';
            removeButton.textContent = 'Remove';
            removeButton.addEventListener('click', () => {
              state.nodeColors.splice(index, 1);
              renderNodeColorList();
            });
            item.appendChild(removeButton);
          }

          nodeColorList.appendChild(item);
        });
      }

      addNodeColorButton.addEventListener('click', () => {
        const newColor = newNodeColorInput.value || '#ffffff';
        state.nodeColors.push(newColor);
        renderNodeColorList();
      });

      const playToggle = document.getElementById('playToggle');
      playToggle.addEventListener('click', () => {
        state.animate = !state.animate;
        playToggle.textContent = state.animate ? 'Pause' : 'Play';
        visibleNodeProgress = state.animate ? MIN_NODES : state.nodeCount;
        lastTimestamp = performance.now();
        if (!state.animate) {
          // Force render with full graph immediately when paused
          drawFrame(0);
        }
      });

      renderNodeColorList();

      window.addEventListener('resize', () => {
        resizeCanvas();
      });

      resizeCanvas();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
